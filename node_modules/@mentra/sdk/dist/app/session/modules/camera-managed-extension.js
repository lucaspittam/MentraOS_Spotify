"use strict";
/**
 * ðŸ“· Camera Module Managed Streaming Extension
 *
 * Extends the camera module with managed streaming capabilities.
 * Apps can request managed streams and receive HLS/DASH URLs without managing RTMP endpoints.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraManagedExtension = void 0;
const types_1 = require("../../../types");
/**
 * ðŸ“¹ Managed Streaming Extension for Camera Module
 *
 * Provides managed streaming capabilities where the cloud handles
 * RTMP endpoints and returns HLS/DASH URLs for viewing.
 *
 * @example
 * ```typescript
 * // Start a managed stream
 * const urls = await session.camera.startManagedStream({
 *   quality: '720p',
 *   enableWebRTC: true
 * });
 * console.log('HLS URL:', urls.hlsUrl);
 * console.log('DASH URL:', urls.dashUrl);
 *
 * // Monitor managed stream status
 * session.camera.onManagedStreamStatus((status) => {
 *   console.log('Managed stream status:', status.status);
 * });
 *
 * // Stop managed stream
 * await session.camera.stopManagedStream();
 * ```
 */
class CameraManagedExtension {
    constructor(packageName, sessionId, send, logger, session) {
        // Managed streaming state
        this.isManagedStreaming = false;
        this.packageName = packageName;
        this.sessionId = sessionId;
        this.send = send;
        this.logger = logger.child({ module: 'CameraManagedExtension' });
        this.session = session;
    }
    /**
     * ðŸ“¹ Start a managed stream
     *
     * The cloud will handle the RTMP endpoint and return HLS/DASH URLs for viewing.
     * Multiple apps can consume the same managed stream simultaneously.
     *
     * @param options - Configuration options for the managed stream
     * @returns Promise that resolves with viewing URLs when the stream is ready
     *
     * @example
     * ```typescript
     * const urls = await session.camera.startManagedStream({
     *   quality: '1080p',
     *   enableWebRTC: true,
     *   video: { fps: 30 },
     *   audio: { sampleRate: 48000 }
     * });
     * ```
     */
    async startManagedStream(options = {}) {
        this.logger.info({ options }, 'ðŸ“¹ Managed stream request starting');
        if (this.isManagedStreaming) {
            this.logger.error({
                currentStreamId: this.currentManagedStreamId
            }, 'ðŸ“¹ Already managed streaming error');
            throw new Error('Already streaming. Stop the current managed stream before starting a new one.');
        }
        // Create the request message
        const request = {
            type: types_1.AppToCloudMessageType.MANAGED_STREAM_REQUEST,
            packageName: this.packageName,
            quality: options.quality,
            enableWebRTC: options.enableWebRTC,
            video: options.video,
            audio: options.audio,
            stream: options.stream,
            restreamDestinations: options.restreamDestinations
        };
        // Send the request
        this.send(request);
        this.isManagedStreaming = true;
        // Create promise to wait for URLs
        return new Promise((resolve, reject) => {
            this.pendingManagedStreamRequest = { resolve, reject };
            // Set a timeout
            setTimeout(() => {
                if (this.pendingManagedStreamRequest) {
                    this.pendingManagedStreamRequest = undefined;
                    this.isManagedStreaming = false;
                    reject(new Error('Managed stream request timeout'));
                }
            }, 30000); // 30 second timeout
        });
    }
    /**
     * ðŸ›‘ Stop the current managed stream
     *
     * This will stop streaming for this app only. If other apps are consuming
     * the same managed stream, it will continue for them.
     *
     * @returns Promise that resolves when the stop request is sent
     */
    async stopManagedStream() {
        if (!this.isManagedStreaming) {
            this.logger.warn('ðŸ“¹ No managed stream to stop');
            return;
        }
        this.logger.info({ streamId: this.currentManagedStreamId }, 'ðŸ“¹ Stopping managed stream');
        const request = {
            type: types_1.AppToCloudMessageType.MANAGED_STREAM_STOP,
            packageName: this.packageName
        };
        this.send(request);
        // Don't clean up state immediately - wait for the 'stopped' status from cloud
        // This ensures we can retry stop if needed and maintains accurate state
    }
    /**
     * ðŸ“Š Check if currently managed streaming
     *
     * @returns true if a managed stream is active
     */
    isManagedStreamActive() {
        return this.isManagedStreaming;
    }
    /**
     * ðŸ”— Get current managed stream URLs
     *
     * @returns Current stream URLs or undefined if not streaming
     */
    getManagedStreamUrls() {
        return this.currentManagedStreamUrls;
    }
    /**
     * ðŸ“Š Get current managed stream status
     *
     * @returns Current stream status or undefined
     */
    getManagedStreamStatus() {
        return this.managedStreamStatus;
    }
    /**
     * ðŸ”” Register a handler for managed stream status updates
     *
     * @param handler - Function to call when stream status changes
     * @returns Cleanup function to unregister the handler
     *
     * @example
     * ```typescript
     * const cleanup = session.camera.onManagedStreamStatus((status) => {
     *   console.log('Status:', status.status);
     *   if (status.status === 'active') {
     *     console.log('Stream is live!');
     *   }
     * });
     *
     * // Later, unregister the handler
     * cleanup();
     * ```
     */
    onManagedStreamStatus(handler) {
        if (!this.session) {
            this.logger.error('Cannot listen for managed status updates: session reference not available');
            return () => { };
        }
        this.session.subscribe(types_1.StreamType.MANAGED_STREAM_STATUS);
        // Register the handler using the session's event system
        return this.session.on(types_1.StreamType.MANAGED_STREAM_STATUS, handler);
    }
    /**
     * Handle incoming managed stream status messages
     * Called by the parent AppSession when messages are received
     */
    handleManagedStreamStatus(status) {
        this.logger.info({
            status: status.status,
            streamId: status.streamId
        }, 'ðŸ“¹ Received managed stream status');
        this.managedStreamStatus = status;
        // Handle initializing status - stream is starting
        if (status.status === 'initializing' && status.streamId) {
            this.isManagedStreaming = true;
            this.currentManagedStreamId = status.streamId;
        }
        // Handle initial stream ready status
        if (status.status === 'active') {
            // Always update state when stream is active
            this.isManagedStreaming = true;
            this.currentManagedStreamId = status.streamId;
            if (status.hlsUrl && status.dashUrl) {
                const result = {
                    hlsUrl: status.hlsUrl,
                    dashUrl: status.dashUrl,
                    webrtcUrl: status.webrtcUrl,
                    streamId: status.streamId || ''
                };
                this.currentManagedStreamUrls = result;
                // Resolve pending promise if exists
                if (this.pendingManagedStreamRequest) {
                    this.pendingManagedStreamRequest.resolve(result);
                    this.pendingManagedStreamRequest = undefined;
                }
            }
        }
        // Handle error status
        if ((status.status === 'error' || status.status === 'stopped') && this.pendingManagedStreamRequest) {
            this.pendingManagedStreamRequest.reject(new Error(status.message || 'Managed stream failed'));
            this.pendingManagedStreamRequest = undefined;
            this.isManagedStreaming = false;
        }
        // Clean up on stopped status
        if (status.status === 'stopped') {
            this.isManagedStreaming = false;
            this.currentManagedStreamId = undefined;
            this.currentManagedStreamUrls = undefined;
        }
        // Notify handlers (would use event emitter in real implementation)
        // this.emit('managedStreamStatus', status);
    }
    /**
     * ðŸ§¹ Clean up all managed streaming state
     */
    cleanup() {
        if (this.pendingManagedStreamRequest) {
            this.pendingManagedStreamRequest.reject(new Error('Camera module cleanup'));
            this.pendingManagedStreamRequest = undefined;
        }
        this.isManagedStreaming = false;
        this.currentManagedStreamId = undefined;
        this.currentManagedStreamUrls = undefined;
        this.managedStreamStatus = undefined;
        this.logger.info('ðŸ“¹ Managed streaming extension cleaned up');
    }
}
exports.CameraManagedExtension = CameraManagedExtension;
